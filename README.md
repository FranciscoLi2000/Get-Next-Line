# Get-Next-Line

这个 **Get Next Line 项目** 旨在通过实现**逐行读取文件描述符**的功能，帮助你掌握以下 **C 语言核心技能** 和 **系统编程实践**：

---

### **核心学习目标**
1. **文件 I/O 与系统调用**
- 使用 `read` 系统调用从文件描述符（`fd`）中读取数据，理解底层 I/O 的阻塞与非阻塞机制。
- 处理多种输入源（普通文件、标准输入 `stdin`、管道等），熟悉文件描述符的通用性。

2. **动态内存管理**
- 动态分配缓冲区（`malloc`）存储临时读取的数据，确保内存正确释放（`free`），避免泄漏。
- 处理长行（如 `BUFFER_SIZE=1` 时需多次读取并拼接字符串），优化内存使用效率。

3. **静态变量的状态管理**
- 使用 `static` 变量保存未读取完的剩余数据，跨函数调用保持状态一致性。
- 在 Bonus 中，扩展静态变量（如链表或数组）以支持多文件描述符并发读取。

4. **缓冲区与读取优化**
- 根据 `BUFFER_SIZE` 动态调整读取策略，处理极端值（如 `BUFFER_SIZE=1` 或 `10000000`）。
- 避免一次性读取整个文件，按需逐块读取以提升性能。

5. **边界条件与健壮性**
- 处理行尾符 `\n` 和文件末尾（EOF），确保返回的字符串格式正确（如最后一行可能无 `\n`）。
- 防御非法输入（如 `fd` 无效、`read` 错误、二进制文件输入）。

6. **模块化设计与工程规范**
- 分离主逻辑（`get_next_line.c`）与工具函数（`get_next_line_utils.c`），提升代码可维护性。
- 遵循 **Norminette** 规范（缩进、函数长度、命名），编写工业级代码。
- 编写高效 `Makefile`，支持编译选项（如 `-D BUFFER_SIZE=42`）和自动化构建。

---

### **关键技术点解析**
#### 1. 单文件描述符实现逻辑
```c
	static char	*remaining_data; // 静态变量保存未处理完的数据
	char		*get_next_line(int fd)
	{
		char	buffer[BUFFER_SIZE + 1];
		ssize_t bytes_read;
		// 1. 从 remaining_data 中提取一行（如有）
		// 2. 若不足一行，调用 read() 读取新数据到 buffer
		// 3. 拼接 remaining_data 与 buffer，更新 remaining_data
		// 4. 返回提取的行
	}
```
**关键点**：正确处理 `remaining_data` 的拼接与切割，避免重复读取或数据丢失。

#### 2. 多文件描述符扩展（Bonus）
```c
	typedef struct s_fd_state
	{
		int	fd;
		char	*remaining_data;
		struct s_fd_state	*next;
	}	t_fd_state;
	static t_fd_state *fd_list; // 静态链表管理多个 fd 的状态
	char	*get_next_line(int fd)
	{
		// 遍历链表，找到或创建对应 fd 的节点
		// 其余逻辑与单 fd 类似，但操作特定节点的 remaining_data
	}
```
**关键点**：使用链表或数组跟踪每个 `fd` 的读取状态，确保并发调用互不干扰。

#### 3. 内存安全与性能优化
- **避免内存泄漏**：每次返回一行后，需更新 `remaining_data` 并释放已处理的部分。
- **高效拼接**：使用 `strjoin` 或手动内存操作减少频繁的 `malloc`/`free` 调用。
- **缓冲区管理**：根据 `BUFFER_SIZE` 调整读取策略，如大缓冲区减少系统调用次数。

---

### **工程实践与思维提升**
1. **防御式编程**
- 检查 `fd` 有效性（如 `fd < 0`）、`read` 返回值（错误或 EOF）。
- 处理 `malloc` 失败场景，返回 `NULL` 并释放已分配内存。

2. **测试驱动开发**
- 编写测试用例覆盖：短行、长行、空文件、二进制文件、交替读取多 `fd`。
- 使用脚本对比 `get_next_line` 与系统工具（如 `cat`）的输出一致性。

3. **性能调优**
- 分析不同 `BUFFER_SIZE` 对读取效率的影响（如时间复杂度和系统调用次数）。
- 优化字符串操作（如使用 `memchr` 快速查找 `\n`）。

---

### **项目隐喻与深层价值**
- **“逐行读取是流处理的基石”**：理解流式数据处理的模式，为后续网络编程（如 HTTP 请求解析）、日志分析打下基础。
- **“静态变量是状态管理的双刃剑”**：掌握如何安全使用静态变量，避免全局状态的副作用。
- **“Norminette 是工业协作的预演”**：适应严格代码规范，提升团队协作能力。

---

### **通关要点**
1. **分步实现**
- 先实现单 `fd` 逻辑，通过基础测试后再扩展 Bonus（多 `fd`）。
- 使用辅助函数（如 `ft_strchr`、`ft_substr`）简化主逻辑。

2. **内存安全第一**
- 使用 `valgrind` 检测内存泄漏，确保所有路径正确释放资源。
- 处理 `remaining_data` 时，避免悬空指针（如 `free` 后置为 `NULL`）。

3. **极端测试**
- 测试 `BUFFER_SIZE=1`（极端低效）和 `BUFFER_SIZE=1000000`（大内存占用）。
- 验证多 `fd` 交替读取（如同时读取文件、管道、`stdin`）。

---

通过此项目，你将从“基础语法使用者”进阶为“系统级开发者”，深入掌握 C 语言在资源管理和状态控制中的核心能力，为后续复杂项目（如 `minishell`、`webserv`）奠定坚实基础。
